{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"kesheng","url":"http://getitkesheng.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"32","date":"2019-06-05T14:28:10.023Z","updated":"2019-06-05T15:11:39.344Z","comments":true,"path":"2019/06/05/32/","link":"","permalink":"http://getitkesheng.github.io/2019/06/05/32/","excerpt":"","text":"title: java—-package语句 fuckfuckfuckfuckffffffffffffffffffffffffffffffffffffff我待java如初恋，它对我一点不留情面，改了前面错后面，bug我求你对我视而不见。改了前面错后面。世上没有最好的编程语言，今晚我想早点睡。。。。。。damn it…. 问题应该是出现自文件结构上，，，，，，，，Student.java文件内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package myClasses; //包语句class Date&#123; //定义日期类 private int year,month,day; //域，表示日期 public Date(int year,int month,int day) //构造方法 &#123; this.year = year; this.month = month; this.day = day; &#125; public int getYear() //获取年 &#123; return year; &#125; public int getMear() //获取月 &#123; return month; &#125; public int getDay() //获取月 &#123; return day; &#125; public String toString() //将日期组成字符串 &#123; return year +&quot;,&quot;+month+&quot;,&quot;+day; &#125;&#125;public class Student //学生类，组合类&#123; private String number; //学号 private String name; //姓名 private char gender; //性别 private Date birthday; //出生日期，用Date类的对象表示 public Student(String number,String name,char gender,int year,int month,int day) //构造方法 &#123; this.number = number; this.name = name; this.gender = gender; birthday = new Date(year,month,day); &#125; public String toString() //将学生信息组成字符串 &#123; String mess = number + &quot;,&quot; + name + &quot;,&quot; + gender + birthday.toString(); return mess; &#125;&#125; Example.java文件内容如下：1234567891011package example;public class Example &#123; public static void main(String args[]) &#123; //Student在包myClasses中，需要加包名前缀 myClasses.Student.stu = new myClasses.Student(&quot;0001&quot;,&quot;张军&quot;,&quot;m&quot;,2005,8,22); System.out.println(stu.toString()); &#125;&#125;","categories":[],"tags":[]},{"title":"MD5加密和解密算法","slug":"31","date":"2019-06-04T16:17:10.795Z","updated":"2019-06-04T16:20:28.533Z","comments":true,"path":"2019/06/05/31/","link":"","permalink":"http://getitkesheng.github.io/2019/06/05/31/","excerpt":"","text":"来自https://blog.csdn.net/lp15203883326/article/details/80481935还没看懂，，，，，，，，，，MD5是不可逆，这里的加密解密，你可以看到是对MD5算法先加密后解密，而不是对MD5的解密1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.test; import java.security.MessageDigest; public class DecryptMD5 &#123; // MD5加码。32位 public static String MD5(String inStr) &#123; MessageDigest md5 = null; try &#123; md5 = MessageDigest.getInstance(&quot;MD5&quot;); &#125; catch (Exception e) &#123; System.out.println(e.toString()); e.printStackTrace(); return &quot;&quot;; &#125; char[] charArray = inStr.toCharArray(); byte[] byteArray = new byte[charArray.length]; for (int i = 0; i &lt; charArray.length; i++) byteArray[i] = (byte) charArray[i]; byte[] md5Bytes = md5.digest(byteArray); StringBuffer hexValue = new StringBuffer(); for (int i = 0; i &lt; md5Bytes.length; i++) &#123; int val = ((int) md5Bytes[i]) &amp; 0xff; if (val &lt; 16) hexValue.append(&quot;0&quot;); hexValue.append(Integer.toHexString(val)); &#125; return hexValue.toString(); &#125; // 可逆的加密算法 public static String KL(String inStr) &#123; // String s = new String(inStr); char[] a = inStr.toCharArray(); for (int i = 0; i &lt; a.length; i++) &#123; a[i] = (char) (a[i] ^ &apos;t&apos;); &#125; String s = new String(a); return s; &#125; // 加密后解密 public static String JM(String inStr) &#123; char[] a = inStr.toCharArray(); for (int i = 0; i &lt; a.length; i++) &#123; a[i] = (char) (a[i] ^ &apos;t&apos;); &#125; String k = new String(a); return k; &#125; // 测试主函数 public static void main(String args[]) &#123; String s = new String(&quot;sa&quot;); System.out.println(&quot;原始：&quot; + s); System.out.println(&quot;MD5后：&quot; + MD5(s)); System.out.println(&quot;MD5后再加密：&quot; + KL(MD5(s))); System.out.println(&quot;解密为MD5后的：&quot; + JM(KL(MD5(s)))); &#125; &#125;---------------------","categories":[],"tags":[]},{"title":"","slug":"30","date":"2019-06-04T15:57:22.877Z","updated":"2019-06-04T16:14:58.290Z","comments":true,"path":"2019/06/04/30/","link":"","permalink":"http://getitkesheng.github.io/2019/06/04/30/","excerpt":"","text":"title 6.4随笔k，，5hao了啊，，好快，又一个月过去了，上个月的今天我好像是在高铁上，上上个月的今天，鼓起勇气向她要微信，当时好紧张，，，哈哈，我记得我说的是，同学，我想认识下你，她好像一句话没说，但还是给了。当时每周都期盼着上体育课，因为能看到她，这一转眼体育课都结课了。她跟我说的第一句话好像是你以后别这样了，好蠢当时，，，发的第一条消息是谢谢你的水，第一次约她是一起去打球，她打球好菜，，，哈哈哈，我完全没认真打啊。她总说自己胖，哪胖啊，那明明叫匀称，一口气能跑十圈，我以前好像从没一次跑过十圈，才发现自己体力这么好，跑十圈感觉完全不费什么力啊，，，她很高，笑的时候眼睛弯弯的，看上去落落大方，但哥，，，，不高，不帅，，，，戴个眼镜，，，，k,屌丝吗这不是，，，我可能是她众多追求者之一，但哥不怂啊，就没怂过，真的很喜欢她，遇到她之前，就没想过大学会谈恋爱啊，，，后来那晚看到的，，，可能也没啥吧，可能是我太狭窄了吧，但我就是感觉永远过不去，，，不说不说了，我想真心的祝愿她可以永远笑的快乐，过的开心，过得好。nnd明天又是满课的一天，，，，","categories":[],"tags":[]},{"title":"站在巨人的肩膀上Ctrlc and Ctrlv","slug":"29","date":"2019-06-02T15:18:46.502Z","updated":"2019-06-02T15:34:06.471Z","comments":true,"path":"2019/06/02/29/","link":"","permalink":"http://getitkesheng.github.io/2019/06/02/29/","excerpt":"","text":"觉得自己在成为调包侠的路上越走越远。。。。。。。。。。。。。。 羡慕那些大牛们，掌握着“原理级技术”，站在某一领域的顶端造轮子，开心了就给个“接口”，小白们拿到“接口”用到自己的项目中，就自以为掌握了它，哈哈，是不是啊，柯小白","categories":[],"tags":[]},{"title":"javascript中window对象的方法 + 属性","slug":"28","date":"2019-06-01T09:11:46.885Z","updated":"2019-06-01T09:13:16.182Z","comments":true,"path":"2019/06/01/28/","link":"","permalink":"http://getitkesheng.github.io/2019/06/01/28/","excerpt":"","text":"window对象有以下方法：open() ，close() ，alert() ，confirm() ，prompt() ，setTimeout() ，clearTimeout() ，setInterval() ，clearInterval() ，moveBy() ，moveTo() ，resizeBy() ，resizeTo() ，scrollBy() ，scrollTo() ，find() ，back() ，forward() ，home() ，stop() ，print() ，blur() ，focus() ，captureEvent() ，ableExternalCapture()，disableExternalCapture() ，handleEvent() ，releaseEvent() ，routeEvent() ，scroll() open()方法 语法格式：window.open(URL,窗口名称,窗口风格) 功能：打开一个新的窗口，并在窗口中装载指定URL地址的网页。 说明：open()方法用于打开一个新的浏览器窗口，并在新窗口中装入一个指定的URL地址；open()方法在打开一个新的浏览器窗口时，还可以指定窗口的名称(第二个参数)；open()方法在打开一个新的浏览器窗口时，还可以指定窗口的风格(第三个参数)，窗口风格有以下选项，这些选项可以多选，如果多选，各选项之间用逗号分隔：toolbar：指定窗口是否有标准工具栏。当该选项的值为1或yes时，表示有标准工具栏，当该选项的值为0或no时，表示没有标准工具栏；location：指定窗口是否有地址工具栏，选项的值及含义与toolbar相同；directories：指定窗口是否有链接工具栏，选项的值及含义与toolbar相同；status：指定窗口是否有状态栏，选项的值及含义与toolbar相同；menubar：指定窗口是否有菜单，选项的值及含义与toolbar相同；scrollbar：指定当前窗口文档大于窗口时是否有滚动条，选项的值及含义与toolbar相同；resizable：指定窗口是否可改变大小，选项的值及含义与toolbar相同；width：以像素为单位指定窗口的宽度，已被innerWidth取代；height：以像素为单位指定窗口的高度，已被innerHeight取代；outerWidth：以像素为单位指定窗口的外部宽度；outerHeight：以像素为单位指定窗口的外部高度；left：以像素为单位指定窗口距屏幕左边的位置；top：以像素为单位指定窗口距屏幕顶端的位置；alwaysLowered：指定窗口隐藏在所有窗口之后，选项的值及含义与toolbar相同；alwaysRaised：指定窗口浮在所有窗口之上，选项的值及含义与toolbar相同；dependent：指定打开的窗口为当前窗口的一个子窗口，并随着父窗口的关闭而关闭，选项的值及含义与toolbar相同；hotkeys：在没有菜单栏的新窗口中设置安全退出的热键，选项的值及含义与toolbar相同；innerHeight：设定窗口中文档的像素高度；innerWidth：设定窗口中文档的像素宽度；screenX：设定窗口距离屏幕左边界的像素长度；screenY：设定窗口距离屏幕上边界的像素长度；titleBar：指明标题栏是否在新窗口中可见，选项的值及含义与toolbar相同；z-look：指明当窗口被激活时，不能浮在其它窗口之上，选项的值及含义与toolbar相同。open方法返回的是该窗口的引用。小技巧：该方法经常用于在打开一个网页时自动打开另一个窗口。 close()方法语法格式：window.close()功能：close方法用于自动关闭浏览器窗口。 alert方法语法格式：window.alert(提示字符串)功能：弹出一个警告框，在警告框内显示提示字符串文本。 confirm方法语法格式：window.confirm(提示字符串)功能：显示一个确认框，在确认框内显示提示字符串，当用户单击“确定”按钮时该方法返回true，单击“取消”时返回false。 prompt方法语法格式：window.prompt(提示字符串，缺省文本)功能：显示一个输入框，在输入框内显示提示字符串，在输入文本框显示缺省文本，并等待用户输入，当用户单击“确定”按钮时，返回用户输入的字符串，当单击“取消”按钮时，返回null值。 setTimeout方法语法格式：window.setTimeout(代码字符表达式,毫秒数)功能：定时设置，当到了指定的毫秒数后，自动执行代码字符表达式。 clearTimeout方法语法格式：window.clearTimeout(定时器)功能：取消以前的定时设置，其中的参数是用setTimeout设置时的返回值。 setInterval方法语法格式：window.setInterval(代码字符表达式,毫秒数)功能：设定一个时间间隔后(第二个参数)，反复执行“代码字符表达式”的内容 clearInterval方法语法格式：window.clearInterval(时间间隔器)功能：取消setInterval设置的定时。其中的参数是setInterval方法的返回值。 moveBy方法语法格式：window.moveBy(水平位移量,垂直位移量)功能：按照给定像素参数移动指定窗口。第一个参数是窗口水平移动的像素，第二个参数是窗口垂直移动的像素。11.moveTo方法语法格式：window.moveTo(x,y)功能：将窗口移动到指定的指定坐标(x,y)处。 resizeBy方法语法格式：window.resizeBy(水平,垂直)功能：将当前窗口改变指定的大小(x,y)，当x、y的值大于0时为扩大，小于0时为缩小。 resizeTo方法语法格式：window.resizeTo(水平宽度,垂直宽度)功能：将当前窗口改变成(x,y)大小，x、y分别为宽度和高度。 scrollBy方法语法格式：window.scrollBy(水平位移量，垂直位移量)功能：将窗口中的内容按给定的位移量滚动。参数为正数时，正向滚动，否则反向滚动。 scrollTo方法语法格式：window.scrollTo(x,y)功能：将窗口中的内容滚动到指定位置。16.find方法语法格式：window.find()功能：当触发该方法时，将弹出一个“find”(查找)对话窗口，并允许用户在触发find方法的页面中查找一个字符串。注：该属性在IE5.5及Netscape6.0中都不支持。 back方法语法格式：window.back()功能：模拟用户点击浏览器上的“后退”按钮，将页面转到浏览器的上一页。说明：仅当当前页面存在上一页时才能进行该操作。注：IE5.5不支持该方法，Netscape6.0支持。 forward方法语法格式：window.forward()功能：模拟用户点击浏览器上的“前进”按钮，将页面转到浏览器的下一页。说明：仅当当前页面存在下一页时才能进行该操作。注：IE5.5不支持该方法，Netscape6.0支持。 home方法语法格式：window.home()功能：模拟用户点击浏览器上的“主页”按钮，将页面转到指定的页面上。注：IE5.5不支持该方法，Netscape6.0支持。 stop方法语法格式：window.stop()功能：模拟用户点击浏览器上的“停止”按钮，终止浏览器的下载操作。注：IE5.5不支持该方法，Netscape6.0支持。 print方法语法格式：window.print()功能：模拟用户点击浏览器上的“打印”按钮，通知浏览器打开打印对话框打印当前页。 blur方法语法格式：window.blur()功能：从窗口中移出焦点。当与focus方法合用时必须小心，因为可能导致焦点不断移进移出。 focus方法语法格式：window.focus()功能：使窗口中得到焦点。当与blur方法合用时必须小心，因为可能导致焦点不断移进移出 captureevent方法语法格式：window.captureevent(event)window.captureevent(事件1|事件2|…|事件n)功能：捕捉指定参数的所有事件。由于能够捕获哪些由本地程序自己处理的事件，所以程序员可以随意定义函数来处理事件。如果有多个事件需要捕捉，各事件之间用管道符“|”隔开。可捕捉的事件类型如下：event.abortevent.blurevent.changeevent.clickevent.dblclickevent.dragdropevent.errorevent.focusevent.keydownevent.keypressevent.keyupevent.loadevent.mousedownevent.mousuemoveevent.mouseoutevent.mouseoverevent.mouseupevent.moveevent.resetevent.resizeevent.selectevent.submitevent.unload enableexternalcapture事件语法格式：window.enableexternalcapture(event)功能：enableexternalcapture方法用于捕捉通过参数传入的外部事件。 disableexternalcapture事件语法格式：window.disableexternalcapture()功能：取消enableexternalcapture方法的设置，终止对外部事件的捕捉。 handleevent事件语法格式：window.handleevent(event)功能：触发指定事件的事件处理器。 releaseevent事件语法格式：window.releaseevent(event)window.releaseevent(事件1|事件2|…|事件n)功能：释放通过参数传入的已被捕捉的事件，这些事件是由window.captureevent方法设置的，可释放的事件与captureevent相同。 routeevent事件语法格式：window.releaseevent(event)功能：把被捕捉类型的所有事件转交给标准事件处理方法进行处理，可转交的事件与captureevent相同。30 scroll事件语法格式：window.scroll(x坐标,y坐标)功能：将窗口移动到指定的坐标位置。6-2-2 window对象的属性window对象具有如下属性：statusstatusbarstatusbar.visibledefaultstatuslocationlocationbarlocationbar.visibleselfnameclosedframesframes.lengthlengthdocumenthistoryinnerheightinnerwidthmenubarmenubar.visibleopenerouterheightouterwidthpagexoffsetpageyoffsetparentpersonalbarpersonalbar.visiblescrollbarscrollbar.visibletoolbartoolbar.visibletop status属性语法格式：window.status=字符串功能：设置或给出浏览器窗口中状态栏的当前显示信息。小技巧：可以使用该属性设置浏览器窗口状态栏信息。 statusbar属性语法格式：window.statusbar.属性功能：statusbar属性本身也是一个对象，用于访问它自已的visible属性从而确定状态栏是否可见。注：ie5.5浏览器不支持该属性。 statusbar.visible属性语法格式：window.statusbar.visible功能：检查状态栏是否可见，如果可见则返回true，反之返回false。注：ie5.5浏览器不支持该属性。 defaultstatus属性语法格式：window.defaultstatus[=字符串]功能：defaultstatus属性值是浏览器窗中状态栏的默认显示信息5.location属性语法格式：window.location=url功能：给出当前窗口的url信息或指定打开窗口的url。 locationbar属性语法格式：window.locationbar.属性功能：locationbar属性也可以看成是一个子对象，这个属性用来获取它自已的visible属性来确定位置栏是否可见。到目前为止，该属性只有一个子属性：visible。注：ie5.5不支持该属性。 locationbar.visible属性语法格式：window.locationbar.visible功能：返回位置栏是否可见，如果可见返回true，反之返回false。注：ie5.5不支持该属性。 self属性语法格式：window.self.方法window.self.属性功能：该属性包含当前窗口的标志，利用这个属性，可以保证在多个窗口被打开的情况下，正确调用当前窗口内的函数或属性而不会发生混乱。 name属性语法格式：window.name=名称功能：返回窗口名称，这个名称是由window.open()方法创建新窗口时给定的。在javascript1.0版本中，这个属性只能用于读取窗口名称，而到了javascript1.1版本时，可以用这个属性给一个不是用window.open()方法创建的窗口指定一个名称。 closed属性语法格式：window.closed功能：closed属性用于返回指定窗口的实例是否已经关闭，如果关闭，返回true，反之返回flase。 frames属性语法格式：window.frames[“框架名称”]window.frames[数值]功能：frames属性是一个数组，用来存储文档中每一个由元素创建的子窗口(框架)实例，其中的下标即可以是次序号也可以是用frame元素的name属性指定的名称来得到并使用。 frames.length属性语法格式：window.frames.length功能：frames.length属性用于给出文档中子窗口(框架)实例的个数。 length属性语法格式：window.length功能：length属性返回一个窗口内的子窗口数目，该属性与window.frame.length属性的值相同。 document属性语法格式：window.document.事件window.document.方法window.document.属性功能：window对象的子对象document是javascript的核心对象，在脚本中遇到body元素时创建一个实例。 history属性语法格式：window.history[数值]window.history.方法()window.history.属性 window.history.back()加载历史列表的上一个url window.history.forward()加载历史列表的下一个url window对象的子对象history是javascript的核心对象之一，该属性包含了一个已访问过页面的名称和url的数组。 innerheight属性语法格式：window.innerheight=数值功能：返回或指定浏览器窗口中文档的像素高度，这个高度不包括任何工具栏和组成窗口的页面修饰高度。注：ie5.5不支持该属性。 innerwidth属性语法格式：window.innerheight=数值功能：返回或指定浏览器窗口中文档的像素宽度，这个宽度不包括任何工具栏和组成窗口的页面修饰宽度。注：ie5.5不支持该属性。 menubar属性语法格式：window.menubar.属性功能：menubar属性也可以看成是一个子对象，这个属性用来获取它自已的visible属性来确定菜单栏是否可见。到目前为止，该属性只有一个子属性：visible。注：ie5.5不支持该属性。 menubar.visible属性语法格式：window.menubar.visible功能：menubar.visible属性用于返回菜单栏是否可见，如果可见返回true，反之返回false。注：ie5.5不支持该属性。 opener属性语法格式：window.openerwindow.opener.方法window.opener.属性功能：opener属性与打开该窗口的父窗口相联系，当访问子窗口中operer属性时，返回的是父窗口。通过该属性，可以使用父窗口对象中的方法和属性。 outerheight属性语法格式：window.outerheight功能：outerheight属性用于访问浏览器窗口的像素高度，该高度包括工具栏和装饰边的高度。注：ie5.5不支持该属性。 outerwidth属性语法格式：window.outerwidth功能：outerwidth属性用于访问浏览器窗口的像素宽度，该宽度包括工具栏和装饰边的宽度。注：ie5.5不支持该属性。 pagexoffset属性语法格式：window.pagexoffset=数值功能：指定浏览器窗口中文档左上角在窗口中的当前水平像素位置。在利用moveto移动之前，可以通过该属性来决定是否需要移动窗口。因为该属性返回了可见文档相对整个页面的当前位置。注：ie5.5不支持该属性。 pageyoffset属性语法格式：window.pageyoffset=数值功能：指定浏览器窗口中文档左上角在窗口中的当前垂直像素位置。在利用moveto移动之前，可以通过该属性来决定是否需要移动窗口。因为该属性返回了可见文档相对整个页面的当前位置。注：ie5.5不支持该属性。 parent属性语法格式：window.parent.frames[数值]window.parent.framesname功能：访问各个子窗口(多框架)所在的父窗口。 personalbar属性语法格式：window.personalbar.属性功能：personalbar属性本身也是一个对象，用于访问其自身的visible属性来确定个人栏是否可见。注：ie5.5不支持该属性。 personalbar.visible属性语法格式：window.personalbar.visible功能：确定个人栏是否可见，如果可见则返回true，反之返回false。注：ie5.5不支持该属性。 scrollbars属性语法格式：window.scrollbars.属性功能：scrollbars属性本身也是一个对象，用于访问其自身的visible属性来确定滚动栏是否可见注：ie5.5不支持该属性。 scrollbars.visible属性语法格式：window.scrollbars.visible功能：scrollbars.visible用于确定滚动栏是否可见，如果可见则返回true，反之返回false。注：ie5.5不支持该属性。 toolbar属性语法格式：window.toolbar.属性功能：toolbar属性本身也是一个对象，用于访问它自已的visible属性从而确定工具栏是否可见。注：ie5.5不支持该属性。 toolbar.visible属性语法格式：window.toolbar.visible功能：toolbar.visible属性用于检查工具栏是否可见，如果可见则返回true，反之返回false。注：ie5.5不支持该属性。 top属性语法格式：window.top.frames[数值]window.top.framenamewindow.top.方法()window.top.属性功能：window对象的top属性用于包含所有装入浏览器的子窗口(多框架)的最顶层窗口的信息。","categories":[],"tags":[]},{"title":"bootstrap字体图标不能显示？","slug":"27","date":"2019-06-01T06:59:17.635Z","updated":"2019-06-01T07:21:32.831Z","comments":true,"path":"2019/06/01/27/","link":"","permalink":"http://getitkesheng.github.io/2019/06/01/27/","excerpt":"","text":"Glyphicons字体图标包括250多个来自 Glyphicon Halflings 的字体图标，但今天在页面中引入字体图标时却发现在前端页面中不能显示，nnd，一番折腾，（给我气死。。。）解决：进入到bootstrap的fonts文件夹内会发现：glyphyicon这个样式，必须要关联到glyphicons-halflings-regular.eot等文件才能正常使用。而我在引入bootstrap.css时是这样引用的1&lt;link rel=&quot;stylesheet&quot; href=&quot;./bootstrap.css&quot;&gt; 可能你也正在和我犯一样的错误，其实在使用大部分bootstrap样式的时候，单单bootstrap.css就够了。但在使用字体图标的时候，就必须关联到字体图标相关文件，还是老老实实这样引入吧：1&lt;link href=&quot;./bootstrap/dist/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;","categories":[],"tags":[]},{"title":"github操作的几个场景（基于Git）","slug":"26","date":"2019-05-30T09:09:37.869Z","updated":"2019-06-05T07:44:47.355Z","comments":true,"path":"2019/05/30/26/","link":"","permalink":"http://getitkesheng.github.io/2019/05/30/26/","excerpt":"","text":"场景1：拉取github上的项目1.克隆项目地址git clone 仓库地址 （. 代表克隆到当前目录，如果在.后写目录名字就把这个仓库克隆到以这个名字为名的文件夹）12345mkdir 文件名（在本地创建该文件夹）cd 文件名（进入该文件）git clone 将要拉取的项目的github网址 （将项目拉取到以创建的文件夹） 场景2：吧自己的项目推送到github仓库1234567891011121314151617181920mkdir 文件名（创建用于存放已经写好的项目的文件夹）cd 文件名git init (初始化仓库)git status 查看本地有哪些文件需要提交，检查后，如果不需要提交， 忽略文件： .gitignore 在这里写的内容将不会推送到远程仓库git add . (把本地的文件添加到仓库)git statusgit commit -am&quot;本次提交的相关注释&quot;git remote add origin 仓库地址 （给本地的仓库加上远程地址）git push origin master (把项目推送到远程仓库，后面是分支（master）名字) 更新仓库代码","categories":[],"tags":[]},{"title":"来自一位主播","slug":"25","date":"2019-05-29T15:31:42.347Z","updated":"2019-05-29T15:36:30.224Z","comments":true,"path":"2019/05/29/25/","link":"","permalink":"http://getitkesheng.github.io/2019/05/29/25/","excerpt":"","text":"十块钱的电子表，跟一百万的劳力士，时间都是一样转， 不要怕被别人瞧不起，那只是你心中的魔鬼。一定要相信自己，一步一步走自己的路。","categories":[],"tags":[]},{"title":"致像我一样的菜鸡","slug":"24","date":"2019-05-29T09:20:13.840Z","updated":"2019-05-29T09:24:46.584Z","comments":true,"path":"2019/05/29/24/","link":"","permalink":"http://getitkesheng.github.io/2019/05/29/24/","excerpt":"","text":"互联网的任何一个技术或应用方向的学习都是永无止境的（今天深深的体会到了）","categories":[],"tags":[]},{"title":"关于vue路由的基本使用","slug":"23","date":"2019-05-28T14:07:34.955Z","updated":"2019-05-28T14:10:23.902Z","comments":true,"path":"2019/05/28/23/","link":"","permalink":"http://getitkesheng.github.io/2019/05/28/23/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang = &quot;en&quot;&gt; &lt;head&gt; &lt;meta charset = &quot;utf-8&quot; /&gt; &lt;title&gt;vue-router多级路由&lt;/title&gt; &lt;link href=&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1. 定义 (路由) 组件。// 可以从其他文件 import 进来const Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; &#125;const Bar = &#123; template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; &#125;// 2. 定义路由// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: &apos;/foo&apos;, component: Foo &#125;, &#123; path: &apos;/bar&apos;, component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // (缩写) 相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router:router&#125;).$mount(&apos;#app&apos;)// 现在，应用已经启动了！&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"打开微信时脑海中突然产生一个想法","slug":"22","date":"2019-05-28T13:24:57.702Z","updated":"2019-05-28T13:43:44.512Z","comments":true,"path":"2019/05/28/22/","link":"","permalink":"http://getitkesheng.github.io/2019/05/28/22/","excerpt":"","text":"对于大多数学生党来说，手机已经是生活必需品了，每天都会打开各种app,其中最多的就是QQ，WeChat，微博，抖音等社交娱乐性软件，那么做一个可以统计你每天打开这些app的次数，时间段，使用时长，并根据每个个体的特点推送一些文字，图片等功能的辅助app或者插件，会不会很有意思。。。。。。。2019.5.28更","categories":[],"tags":[]},{"title":"关于bootstrap如何在html页面加载使用","slug":"21","date":"2019-05-28T12:06:43.283Z","updated":"2019-05-28T12:24:13.576Z","comments":true,"path":"2019/05/28/21/","link":"","permalink":"http://getitkesheng.github.io/2019/05/28/21/","excerpt":"","text":"写了一个关于vue-router基本使用的html页面，在其中引入了bootstrap,却发现部分功能不能实现，检查后不是代码的问题，Google后才知道是因为bootstrap插件都依赖jQuery,使用bootstrap必须下载jQuery支持。下面介绍两种使得bootstrap能够在页面中正常加载并使用的方法：1.将jQuery和bootstrap下载到本地，具体步骤如下： 到bootstrap官方网站下载，对于我们开发者来说，直接下载编译和压缩后的CSS、JavaScript文件，另外还包含字体文件，但是不包含文档和源码文件。打开解压包之后可以发现包含三个文件夹 css、fonts、js。这是最基本的Bootstrap组织形式：未压缩版的文件可以在任意web项目中直接使用。我们提供了压缩(bootstrap.min.)与未压缩 (bootstrap.)的CSS和JS文件。字体图标文件来自于Glyphicons 所有Bootstrap插件都依赖jQuery。而且在正式的项目当中我们推荐使用压缩之后的版本，因为它的体积很小，到官网下载jQuery支持. 将下载后的就jQuery放到bootstrap中的js目录下 在bootstrap的根目录下新建一个demo.html文件，（注意，必须在根目录下面新建，因为后面的步骤中要将bootstrap框架中的css和js文件链接到创建的demo中） 编辑demo.html文件，添加对bootstrap框架中css和js的引用，内容如下，这样，我们就基本上建立了对bootstrap框架的基本使用架构.源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!-- viewport的&lt;meta&gt;标签，这个标签可以修改在大部分的移动设备上面的显示，为了确保适当的绘制和触屏缩放。--&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;!--样式文件引用--&gt;&lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;&lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]IE9以下的浏览器并不支持这些标签，也不能为这些标签进行添加样式。那么修复这个问题我们需要链接引用的文件意思就是说如果用户IE浏览器的版本小于IE9，那么就会加载这两个js文件库，现在就可以使用这些新的标签，并且可以在这些标签上添加样式了--&gt;&lt;/head&gt;&lt;body&gt;&lt;!--JavaScript插件都是依赖于jQuery库--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-2.1.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.啥也不用干，因为bootstrap官方提供了连接服务，所以可以直接在html中引入它。代码如下：12345&lt;link href=&quot;http://libs.baidu.com/bootstrap/3.0.3/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"vue全家桶--安装前期准备nodejs+cnpm+webpack+vue-cli+vue-router","slug":"20","date":"2019-05-27T08:52:45.881Z","updated":"2019-05-27T08:55:06.606Z","comments":true,"path":"2019/05/27/20/","link":"","permalink":"http://getitkesheng.github.io/2019/05/27/20/","excerpt":"","text":"写在前面： 什么是全家桶？ 包含了vue-router（http://router.vuejs.org），vuex（http://vuex.vuejs.org）， vue-resource（https://github.com/pagekit/vue-resource）。再加上构建工具vue-cli，sass/less样式,就是一个完整的vue项目的核心构成。 概括起来就是：、1.项目构建工具、2.路由、3.状态管理、4.http请求工具。 其他：axios是一个http请求包，vue官网推荐使用axios进行http调用。 1.安装nodejs。 Node.js官方安装包及源码下载地址：http://nodejs.org/download/ 一路next，安装完毕。 1.命令行操作：win+r键调出运行，输cmd调出命令行。 2.检查Node.js版本看是否安装成功：输入node -v。 2.将淘宝镜像cnpm安装，解决npm外国安装过慢问题。 1.打开命令行，输入 npm install -g cnpm –registry=https://registry.npm.taobao.org-g和-global同样都是全局的意思，以后再有新项目都不用再重复操作安装依赖了。安装好以后用cnpm 替代所有npm命令。 （可以简写为cnpm i -g cnpm –registry=https://registry.npm.taobao.org，这里的i就是指的install,以后不再赘述） 如果安装失败，可以使用 npm cache clean 清理缓存，然后再重新安装。后面的安装过程中，如有安装失败的情况，也需要先清理缓存。 同样可以使用 cnpm -v 查看是否安装成功。 3.使用 cnpm 安装 vue-cli 脚手架和 webpack。最新的 vue 项目模板中，都带有 webpack 插件，所以这里可以不安装 webpack。 cnpm install -g vue-cli安装完成后，可以使用 vue -V （注意 V 大写）查看是否安装成功。如果提示“无法识别 ‘vue’ ” ，有可能是 npm 版本过低，可以使用 npm install -g npm 来更新版本 4.初始化项目 vue init webpack 项目名称比如在桌面shift右键调出命令行，输入vue init webpack my-vue ，然后一路回车过去，会默认自动安装vue-router，行使ESLint规范等。 5.然后进入项目目录，使用 cnpm 安装依赖 cd my-vue cnpm i 然后启动项目 npm run dev 浏览器打开输入：http://localhost:8080 6自己的项目文件都需要放到 src 文件夹下 7.项目开发完成之后，可以进行打包工作 npm run build 打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看 项目上线时，只需要将 dist 文件夹放到服务器就行了。","categories":[],"tags":[]},{"title":"随笔","slug":"19","date":"2019-05-25T15:25:04.603Z","updated":"2019-05-25T15:48:30.749Z","comments":true,"path":"2019/05/25/19/","link":"","permalink":"http://getitkesheng.github.io/2019/05/25/19/","excerpt":"","text":"5.25，阴，距离暑假只有一个多月时间了，这学期计划好的很多事都没有完成，加上最近发生的一些事，搞得自己有点难受，哈哈（假装乐观），没事，明天又是新的一天。curry，fire！！！ 我的文笔真的好烂，不知道今天怎么会想起写一篇随笔，主要想提醒一下自己，在距离暑假只剩这一个多月的时间里，要做好三件事：1.继续准备四六级2.复习，准备期末考试3.因为从大一就开始自学web前端了，所以接下来要通过各种途径寻找实习，尽力在暑假可以找到相关实习，提升专业技能，为了以后不用996。就写到这吧，，，，，，，，宝宝心里苦","categories":[],"tags":[]},{"title":"斐波那契数列的递归与非递归实现","slug":"18","date":"2019-05-25T13:53:41.292Z","updated":"2019-05-25T15:16:56.372Z","comments":true,"path":"2019/05/25/18/","link":"","permalink":"http://getitkesheng.github.io/2019/05/25/18/","excerpt":"","text":"非递归123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a=1,b=1,c=2,i,n; printf(&quot;你想知道斐波那契数列的第几项:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(i=4;i&lt;=n;i++) &#123; a=b; b=c; c=a+b; &#125; printf(&quot;斐波那契数列的第%d项为：%d&quot;,n,c); return 0;&#125; 递归nnd,写这么个玩意儿写半个多小时，我真的菜的抠脚123456789101112131415161718192021222324#include&lt;stdio.h&gt;int Fib(n)&#123; if(n&lt;=0) printf(&quot;data error!&quot;); else if(n==1||n==2) return 1; else &#123; return Fib(n-1) + Fib(n-2); &#125; &#125;int main()&#123; int a=1,b=1,c=2,i=4,n,s; while(1) &#123; printf(&quot;你想知道斐波那契数列的第几项:\\n&quot;); scanf(&quot;%d&quot;,&amp;n); s=Fib(n); printf(&quot;斐波那契数列的第%d项为：%d\\n&quot;,n,s); &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"n! 的递归与非递归实现","slug":"17","date":"2019-05-25T13:30:25.185Z","updated":"2019-05-25T13:51:14.817Z","comments":true,"path":"2019/05/25/17/","link":"","permalink":"http://getitkesheng.github.io/2019/05/25/17/","excerpt":"","text":"非递归1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int n,s; s=1; printf(&quot;请输入用于做阶乘运算的整数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); while(n&gt;0) &#123; s=s*n; n--; &#125; printf(&quot;阶乘结果为：%d\\n&quot;,s); return 0;&#125; 递归12345678910111213141516#include&lt;stdio.h&gt;int jc(n) &#123; if(n&lt;=1) return 1; else return n*jc(n-1); &#125;int main()&#123; int n,s; printf(&quot;请输入用于做阶乘运算的整数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); s=jc(n); printf(&quot;阶乘结果为：%d\\n&quot;,s); return 0;&#125;","categories":[],"tags":[]},{"title":"哈希查找","slug":"16","date":"2019-05-23T08:25:16.970Z","updated":"2019-05-23T08:28:50.893Z","comments":true,"path":"2019/05/23/16/","link":"","permalink":"http://getitkesheng.github.io/2019/05/23/16/","excerpt":"","text":"定义哈希查找是通过计算数据元素的存储地址进行查找的一种方法。 哈希查找的操作步骤：⑴用给定的哈希函数构造哈希表；⑵根据选择的冲突处理方法解决地址冲突；⑶在哈希表的基础上执行哈希查找。","categories":[],"tags":[]},{"title":"5.20? 今天陪伴我一整天的竟然是coding.......","slug":"15","date":"2019-05-20T07:59:38.387Z","updated":"2019-05-20T09:02:10.646Z","comments":true,"path":"2019/05/20/15/","link":"","permalink":"http://getitkesheng.github.io/2019/05/20/15/","excerpt":"","text":"写个表白的program吧！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset = &quot;utf-8&quot;&gt; &lt;title&gt;5.20专属告白代码，拿去不谢！&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = &quot;love0&quot;&gt; &lt;p&gt;亲爱的xxx,我是爱你的xxx&lt;/p&gt; &lt;br&gt; &lt;p&gt;今天是5.20，我想对你说些心里话，你想听吗？&lt;/p&gt; &lt;br&gt; &lt;button id = &quot;btn0&quot;&gt;想听想听&lt;/button&gt; &lt;button id = &quot;btn1&quot;&gt;不想&lt;/button&gt; &lt;/div&gt; &lt;div id = &quot;love1&quot; style = &quot;display:none&quot;&gt; &lt;img src = &quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E5%91%8A%E7%99%BD%E5%9B%BE%E7%89%87%E5%A4%A7%E5%85%A8&amp;hs=2&amp;pn=6&amp;spn=0&amp;di=84040&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;ie=utf-8&amp;oe=utf-8&amp;cl=2&amp;lm=-1&amp;cs=2184502705%2C2172441180&amp;os=3852216142%2C1638428626&amp;simid=0%2C0&amp;adpicid=0&amp;lpn=0&amp;ln=30&amp;fr=ala&amp;fm=&amp;sme=&amp;cg=&amp;bdtype=0&amp;oriquery=%E5%91%8A%E7%99%BD%E5%9B%BE%E7%89%87%E5%A4%A7%E5%85%A8&amp;objurl=http%3A%2F%2Fimg.99danji.com%2Fuploadfile%2F2018%2F0516%2F20180516012609384.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bll1wg3t_z%26e3Bv54AzdH3FwzAzdH3Fbl80a8AzdH3F&amp;gsm=0&amp;islist=&amp;querylist=&quot;&gt; &lt;p&gt;没有动人的情话，只有爱你的真心，和守护你一辈子的决心&lt;/p&gt; &lt;br&gt; &lt;p&gt;爱你是我今生最美的歌，想你却是今生最快乐的坚持，念你是我今生最开心的追求，恋你是我今生最得意的故事。&lt;/p&gt; &lt;br &lt;p&gt;就算时光风化了记忆，我仍会用我一生唱着，520我爱你！&lt;/p&gt; &lt;br&gt; &lt;p&gt;表白人：xxx&lt;/p&gt; &lt;p&gt;看的我自己都想吐。。。。。。。。。，样式也懒得写了！&lt;/p&gt; &lt;/div&gt; &lt;img id = &quot;img1&quot; src = &quot;https://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%88%91%E7%88%B1%E4%BD%A0%E5%9B%BE%E7%89%87&amp;hs=2&amp;pn=1&amp;spn=0&amp;di=128480&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0%2C0&amp;ie=utf-8&amp;oe=utf-8&amp;cl=2&amp;lm=-1&amp;cs=1507873901%2C3088704631&amp;os=723829148%2C3963648281&amp;simid=0%2C0&amp;adpicid=0&amp;lpn=0&amp;ln=30&amp;fr=ala&amp;fm=&amp;sme=&amp;cg=&amp;bdtype=0&amp;oriquery=%E6%88%91%E7%88%B1%E4%BD%A0%E5%9B%BE%E7%89%87&amp;objurl=http%3A%2F%2Fku.90sjimg.com%2Felement_origin_min_pic%2F18%2F01%2F04%2F4dbbd8f770c58a67a7b476c4604bd489.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Flafij3t_z%26e3Bv54AzdH3Ff7vwtAzdH3F8lndn9da_z%26e3Bip4s&amp;gsm=0&amp;islist=&amp;querylist=&quot; style = &quot;display:none&quot;&gt; &lt;script&gt; window.onload = function()&#123; var btn0 = document.getElementById(&quot;btn0&quot;); var btn1 = document.getElementById(&quot;btn1&quot;); var love1 = document.getElementById(&quot;love1&quot;); var img1 = document.getElementById(&quot;img1&quot;); btn0.onclick = function()&#123; love1.style.display = &apos;block&apos;; alert(&quot;做我女朋友好吗？xxx&quot;); img1.style.display = &quot;block&quot;; &#125; btn1.onclick = function()&#123; alert(&quot;你不想听我也要说，哼！&quot;); love1.style.display = &apos;block&apos;; alert(&quot;做我女朋友好吗？xxx&quot;); img1.style.display = &quot;block&quot;; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"顺序栈实现（基于C语言,未完待续....）","slug":"14","date":"2019-05-20T07:59:38.387Z","updated":"2019-05-20T08:04:19.581Z","comments":true,"path":"2019/05/20/14/","link":"","permalink":"http://getitkesheng.github.io/2019/05/20/14/","excerpt":"","text":"功能要求：顺序栈的初始化，入栈，出栈，判断顺序栈是否为空，顺序栈的输出及求顺序栈长度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 /*顺序栈*/#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;process.h&gt;#define STACK_INIT_SIZE 10#define STACKINCREMENT 5#define MAXQSIZE 100#define OK 1#define Error 0typedef char QElemType;int yes = 0;typedef struct&#123; //顺序栈结构 char *base; char *top; int stacksize;&#125;SeqStack;void CreateStack(SeqStack *Q) //创建顺序栈操作&#123; int i,length; char ch; printf(&quot;请输入顺序栈长度：\\n&quot;); scanf(&quot;%d&quot;,&amp;length); for(i=0;i&lt;length;i++) &#123; printf(&quot;请输入顺序栈的元素：\\n&quot;); scanf(&quot;%c&quot;,&amp;ch); if((ch=getchar()) != &apos;\\n&apos;) *Q-&gt;top++ = ch; //***有点思维,注意运算符顺序*** &#125; yes = 1;&#125;int push(SeqStack *S,char e) //顺序栈入栈操作&#123; &#125;int menu() //顺序栈操作菜单&#123; printf(&quot;\\t\\t\\t顺序栈基本操作实验\\n&quot;); printf(&quot;*************************************************************\\n&quot;); printf(&quot;1.建立顺序栈\\n&quot;); printf(&quot;2.顺序栈入栈操作\\n&quot;); printf(&quot;3.顺序栈出栈操作\\n&quot;); printf(&quot;4.求顺序栈长度\\n&quot;); printf(&quot;5.判断顺序栈是否为空\\n&quot;); printf(&quot;6.输出顺序栈\\n&quot;); printf(&quot;7.销毁顺序栈\\n&quot;); printf(&quot;8.退出\\n&quot;); printf(&quot;*************************************************************\\n&quot;); return 0;&#125;int func() //各种功能函数封装&#123; SeqStack ptr; int sel; char ch; InitStack(&amp;ptr); while(1) &#123; menu(); printf(&quot;请输入指令（0-7）：\\n&quot;); scanf(&quot;%d&quot;,&amp;sel); switch(sel)&#123; case 1:if(yes == 1) &#123; printf(&quot;此时顺序栈已创建，不能再次创建！\\n&quot;); break; &#125; else CreatStack(&amp;ptr); break; case 2:if(yes == 0) &#123; printf(&quot;此时顺序栈未创建，不能入栈！抱歉！&quot;); break; &#125; else &#123; printf(&quot;请输入栈的元素值：\\n&quot;); scanf(&quot;%c&quot;,&amp;ch); if((ch=getchar()) != &apos;\\n&apos;) push(&amp;ptr,ch); break; &#125; &#125; &#125;&#125;int main(void) //程序入口&#123; func(); return OK;&#125;","categories":[],"tags":[]},{"title":"框架一时用一时爽，一直用一直爽","slug":"13","date":"2019-05-18T14:26:23.886Z","updated":"2019-05-18T14:28:34.602Z","comments":true,"path":"2019/05/18/13/","link":"","permalink":"http://getitkesheng.github.io/2019/05/18/13/","excerpt":"","text":"咋办！！！用习惯了到时原生的一点不会写就麻烦了","categories":[],"tags":[]},{"title":"如何理解Vue的MVVM（Model-View-ViewModel）架构设计模式","slug":"12","date":"2019-05-17T09:20:03.974Z","updated":"2019-05-17T09:35:53.736Z","comments":true,"path":"2019/05/17/12/","link":"","permalink":"http://getitkesheng.github.io/2019/05/17/12/","excerpt":"","text":"其实还是不理解，不亲手撸代码，不搞点东西出来，还是不能深刻理解——-柯盛Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。它不仅易于上手，还便于与第三方库或既有项目整合。 1、说明：MVVM 是Model-View-ViewModel 的缩写，核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，这就是数据双向绑定。 Vue.js 又提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性。 View 和 Model 之间的同步工作完全是自动的，无需人为干涉。 ###2、类比 ：Model:指的是数据部分，对应到前端相当于javascript对象 View:指的是视图部分，对应前端相当于dom Viewmodel:就是连接视图与数据的中间件通讯","categories":[],"tags":[]},{"title":"希尔排序","slug":"11","date":"2019-05-17T08:23:21.792Z","updated":"2019-05-17T08:24:38.355Z","comments":true,"path":"2019/05/17/11/","link":"","permalink":"http://getitkesheng.github.io/2019/05/17/11/","excerpt":"","text":"C语言实现希尔排序123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;void main()&#123; int i,j,t0,t1,k,n; int a[100]; printf(&quot;请输入你想要排序的数字的总个数：&quot;); scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) //为数组赋值 scanf(&quot;%d&quot;,&amp;a[i]); for(i=n/2;i&gt;=1;i=i/2) //增量序列的间隔排序 for(j=0;j&lt;n&amp;&amp;i&lt;n;j++)&#123; if(a[j]&gt;a[i])&#123; t0=a[j]; a[j]=a[i]; a[i]=t0; i=i+1; &#125; &#125; for(j=1;j&lt;n;j++)&#123; //插入排序 k=j-1; while(k&gt;=0&amp;&amp;a[k]&gt;a[j])&#123; t1=a[k]; a[k]=a[j]; a[j]=t1; k--; j--; &#125; &#125; printf(&quot;经过希尔排序后的结果为：\\n&quot;); for(i=0;i&lt;n;i++) printf(&quot;%3d&quot;,a[i]); printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;\\n&quot;); printf(&quot;注：此程序只体现了个人对于希尔排序算法的理解，尚有诸多不完善之处&quot;);&#125;","categories":[],"tags":[]},{"title":"查找算法之二分查找实现及算法分析","slug":"10","date":"2019-05-16T12:26:06.807Z","updated":"2019-05-16T12:33:44.722Z","comments":true,"path":"2019/05/16/10/","link":"","permalink":"http://getitkesheng.github.io/2019/05/16/10/","excerpt":"","text":"Java实现（主要算法思想）123456789101112131415161718public static int recursionBinarySearch(int[] arr,int key,int low,int high)&#123; if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123; return -1; &#125; int middle = (low + high) / 2; //初始中间位置 if(arr[middle] &gt; key)&#123; //比关键字大则关键字在左区域 return recursionBinarySearch(arr, key, low, middle - 1); &#125;else if(arr[middle] &lt; key)&#123; //比关键字小则关键字在右区域 return recursionBinarySearch(arr, key, middle + 1, high); &#125;else &#123; return middle; &#125; &#125; C语言实现12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;int binarysearch(int x,int v[],int n) //二分查找函数定义&#123; int low,high,mid; low = 0; high = n-1; while(low&lt;=high) &#123; mid = (low+high)/2; if(x&lt;v[mid]) high = mid-1; else if(x&gt;v[mid]) low = mid+1; else return mid; &#125; return -1;&#125;int main()&#123; int m,a[2019],i,fd,s; printf(&quot;请输入将输入的数据的个数：\\n&quot;); scanf(&quot;%d&quot;,&amp;m); printf(&quot;请输入以排序好的数据：\\n&quot;); for(i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;请输入将要查找的数据：\\n&quot;); scanf(&quot;%d&quot;,&amp;s); fd = binarysearch(s,a,m); if(fd == -1) printf(&quot;查找的数据不存在！&quot;); else printf(&quot;查找的数据所在位置为：%d\\n&quot;,fd); return 0;&#125; 算法分析二分法的时间复杂度是O(logn)，且要求数组是经过排序的。如果没有排过序，就只好先用O（nlogn)的预处理为它排个序了。而且它的插入比较困难，经常需要移动整个数组，所以动态的情况下比较慢。","categories":[],"tags":[]},{"title":"顺序栈实现","slug":"09","date":"2019-05-15T14:26:57.143Z","updated":"2019-05-15T14:29:08.933Z","comments":true,"path":"2019/05/15/09/","link":"","permalink":"http://getitkesheng.github.io/2019/05/15/09/","excerpt":"","text":"构思撰写ing……………敬请期待！","categories":[],"tags":[]},{"title":"来自知乎的一篇推送","slug":"08","date":"2019-05-15T14:19:54.810Z","updated":"2019-05-15T14:26:50.985Z","comments":true,"path":"2019/05/15/08/","link":"","permalink":"http://getitkesheng.github.io/2019/05/15/08/","excerpt":"","text":"发表过论文么参加过国家比赛么拿过国奖么保研了么参加过创业项目么当过学生会主席么去邻校蹭过课么万众瞩目下表现过么在母校出名了么假期实习过么打过工么创过业么有自己的社团么大学食堂吃遍了么远足过么和学校领导交流过么图书馆的书看过百分之一了么每个教室都自习过么一科考试都没挂过么好好哭过么一夜不眠过么和兄弟出去浪一宿过么和导员盘腿扯过淡么有两个以上的好哥们么修第二专业了么考上研究生了么考过驾校么四六级过了么在寝室偷煮过火锅么说好的下学期好好学习做到了么那么多做过的没做过的事你却只想到没对象扎心了么","categories":[],"tags":[]},{"title":"关于如何修改Mysql数据库密码","slug":"07","date":"2019-05-14T13:15:51.819Z","updated":"2019-05-14T13:38:45.918Z","comments":true,"path":"2019/05/14/07/","link":"","permalink":"http://getitkesheng.github.io/2019/05/14/07/","excerpt":"","text":"Mysql 5.7版本之前：命令行输入：123mysql -u root -p 回车提示输入密码：(原始密码)update user set password=password(&apos;新密码&apos;) WHERE User=&apos;root(用户名)&apos;; Mysql 5.7版本之后，方法1：命令行输入：1234mysql -u root -p 回车提示输入密码：(原始密码)update mysql.user set authentication_string=password(&apos;新密码&apos;)where user = &apos;root(用户名)&apos; and Host = &apos;localhost(主机名)&apos;;flush privileges; //刷新MySQL的系统权限相关表 方法2：命令行输入：1mysqladmin -u root -p password 新密码 以上所有操作默认已配置好MySQL的环境变量。","categories":[],"tags":[]},{"title":"关于JS对象原型prototype与继承，ES6的class和extends","slug":"06","date":"2019-05-12T03:07:07.520Z","updated":"2019-05-12T03:17:44.427Z","comments":true,"path":"2019/05/12/06/","link":"","permalink":"http://getitkesheng.github.io/2019/05/12/06/","excerpt":"","text":"传统方式：通过function关键字来定义一个对象类型1234567891011function People(name) &#123; this.name = name&#125;People.prototype.toSay= function () &#123; alert(&quot;我的名字是：&quot; + this.name)&#125;People.prototype.toEat= function () &#123; alert(&quot;我吃饭&quot;)&#125;var p = new People(&quot;小明&quot;)p.toSay(); // 我的名字是小明 上面的代码里，我们定义People这种类型，它的属性特征有name、toSay、toEat 。然后我们以People为模板new出来一个p的实例对象。刚接触js时，可能会疑惑，function声明的不是函数么，怎么又变成定义对象类型？prototype是什么？其实在js中，函数本身也是一个对象。这种对象有点特殊，它的作用是定义了对象类型，可以说是数据结构模板。 而prototype是它的一个属性，称为对象原型，其本质也是一个对象，包含constructor和其他属性成员。constructor默认指向自身构造函数。所以声明People的时候，程序自动People对象添加了prototype属性，并且让prototype.constructor指向了People，即函数本身。所以上面的例子等同于下面的写法：12345678910111213function People(name) &#123; this.name = name&#125;var proto = &#123; constructor : People, toSay: function (name) &#123; alert(&quot;我的名字是：&quot; + name) &#125;, toEat: function() &#123; alert(&quot;我吃饭&quot;) &#125;&#125;People.prototype = proto // 指定People的Prototype属性 prototype的作用：当我们new一个实例对象p时，程序根据对象类型People的原型prototype，将原型所定义的属性（constructor除外）复制给新的实例对象p，并执行了一次prototype.constructor 所指向的构造函数，对实例对象p进行初始化。实例对象p有两种属性：实例属性、原型属性实例属性： 构造方法里定义的原型属性： 在原型prototype里定义hasOwnProperty方法可以帮我们区分p.hasOwnProperty(“name”); // truep.hasOwnProperty(“toSay”); // false,因为这个属性是原型上定义的 问题1：为什么我们不直接都在构造函数里面定义呢？123456789function People(name) &#123; this.name = name this.toSay = function() &#123; alert(&quot;我的名字是：&quot; + this.name) &#125; this.toEat = function() &#123; alert(&quot;我吃饭&quot;) &#125;&#125; 答： 这个主要考虑内存管理，因为函数是内存中的一个对象，也就是说，toSay或toEat都是对象占有一定内存。写在构造函数里面，每new一个实例对象，都会执行一次构造函数，都会重新创建一个函数对象，赋给新的实例对象的属性上。结果就是每一个实例对象的toSay或toEat属性都对应各自的函数对象，而这些函数功能都是一样的，我们创建了一大堆重复的函数对象。使用prototype不会，因为大家共享一个prototype对象。问题2： 为什么name不是直接定义在原型prototype上呢？答：每个人名字不同，如果定义在prototype上，大家名字就一样了，其中一个改变了name值，都会影响到其他实例对象。注意：实例对象是没有prototype属性，所以你不可以用实例对象为模板new一个新的实例对象来，只能用函数对象为模板来创建。var p1 = new People(‘’小明”)； // 正确，函数对象的prototype的constructor指定构造方法var p2 = new p1(“小王”) ； // error ,实例对象没有prototype，找不到构造方法 各大浏览器厂商给实例对象实现了一个 proto 属性，指向对象原型，我们称为实例对象的隐式原型，即：var p1 = new People(“小明”)p1.proto === People.prototype // true 但我们要避免使用这个属性， 这个属性作用我猜测是浏览器提供给我们方便调试的时候用的。 问题1：People.prototype是一个对象，这个对象是什么？答：Object， js所有对象默认继承js内置对象Object。问题2： js中，怎么实现对象的继承？答：js的继承是通过对象原型prototype来实现的。1234567891011121314151617// 父类型function Animal(name) &#123; this.name= name this.hasFoot = true this.color = [&quot;orange&quot;, &apos;&apos;black&quot;]&#125;Animal.prototype = &#123; constructor: Animal, voice: function(word) &#123; console.info(word) &#125; &#125;// 子类型 Catfunction Cat() &#123;&#125;Cat.prototype = new Animal(&quot;cat&quot;); // Cat.prototype.constructor是AnimalCat.prototype.constructor = Cat; // 我们将构造函数指定回来，因为我们可以在构造扩展其它属性 上面的代码，我们就实现了Cat的对象类型是继承了Animal对象类型，所以我们可以看到：1234var cat1 = new Cat()cat1.hasFoot // truecat1.color // [&quot;orange&quot;,&quot;black&quot;]cat1.toString // function toString() &#123; [native code] &#125; hasFoot、与footNum都是从父类型annimal继承过来的，而toString为什么有呢，其实是这样，Cat继承了Animal，而Animal默认继承了Object，所以当我们找cat1的toString属性是，发现自身实例属性没有，发现原型上也没有定义，那程序就会寻所继承的父对象的实例属性，父对象的原型属性，这样一步步找下去，这就是JS的原型链。所以就是：12cat1.__proto__ === Cat.prototype // truecat1.__proto__.__proto__ === Animal.prototype // true ,因为Cat.prototype是一个Animal的实例对象 上面的程序设计存在一个问题，有的猫只有一种颜色，有猫身上的颜色有三种，橘、白、黑。显然从Animal继承过来的颜色只有不能满足这种情况1234var cat2 =new Cat()cat2.color.push(&quot;white&quot;);cat1.color // [&quot;orange&quot;, &quot;black&quot;, &quot;white&quot;]//原因是因为，color是来自Cat.prototype，cat1和cat2共享一个prototype，你改变了cat2，cat1的color原型属性就会受到影响 面对这种情况，我们的Cat对象类型应该这么写：12345678function Cat() &#123; Animal.call(this) // 这样就可以将原型的实例属性变成自身的实例属性&#125;Cat.prototype = new Animal()Cat.prototype.constructor = Catvar cat1 = new Cat()var cat2 = new Cat()cat1.color === cat2.color // false 虽然的方式解决了问题，但是还是有个缺点，调用了两次Animal构造函数。第一次是指定Cat.prototype，第二次是Cat自身构造函数中主动调用。我们更想要的是，指定了prototype，new实例时，构造函数就不要再调用Animal()了。此时我们需要一个工具来完成1234567891011// 工具extendfunction extend(super, suber) &#123; var proto = Object.create(super.prototype) proto.constructor = suber suber.prototype = proto&#125;function Cat() &#123; Animal.call(this); &#125;extend(Animal, Cat) 上面的这种方式，将指定Cat.prototype从通过new Animal()换成直接Object.creat(Animal.prototype),这样就避免了Animal() 构造函数的执行。实际上，这方式是最高效的方式。对比其他面向对象开发语言(如： java)，js通过function定义对象类型，容易让人不理解。ES6新规范推出class和extends关键字来实现面向对象编程。ES6方式：用class关键字定义对象类型，用extends关键字实现继承12345678910111213141516171819202122232425262728const private2 = Symbol(&apos;I am symbol value&apos;)class A &#123; a1 = &apos;1&apos; // ES7 实例属性，需要new实例来访问, ES6规定class没有静态属性，只有静态方法所以只能在constructor中定义属性 static a2 = &apos;2&apos; // ES7的静态属性，直接 A.a2 访问，不需要new实例 getA1() &#123; return this.a1 // this指向new实例 &#125; static getA2() &#123; return ‘2’ // 静态方法 &#125; constructor(name) &#123; //一定要有构造方法，如果没有默认生成空构造方法 this.a3 = &apos;3&apos; // 这里定义实例属性 this.name = name &#125; // 私有方法写法 publicMethod() &#123; private1() // 私有方法1，可以写在class体外 private2() // 利用Symbol值来定义 &#125; [private2]() &#123; // 这里是私有方法 &#125;&#125;const private1 = function() &#123; // 这里也是私有方法，但别export出去&#125;// 最后export classexport default A class关键字会让我们更清晰设计一个对象类型，实际上,这只是语法糖： A 的实质还是一个function对属性的定义是实例属性，而对方法的定义是定义在原型上 // 通过extends继承12345678class B extends A&#123; constructor() &#123; // 一定要在构造函数的第一句调用super super() // 这是调用父类的构造方法 this.b1 = &apos;11&apos; this.b2 = super.a1 // super直接调用时指向父类构造方法，范围属性时，指向父类实例，或调用父类静态方法 &#125;&#125; 我们可以知道，实际上A、B都是两个对象类型，B继承A。ES6的class作为语法糖也提供了prototype和proto两个属性；1234567891011let instanceA = new A()let instanceB = new B()A.prototype // ObjectinstanceA.__proto__ //即A.prototype 还是ObjectB.prototype // A的实例对象，并且constructor指定为ClassBinstanceB.__proto__ //B.prototypeinstanceB.__proto__.__proto__ // 即A.prototype ,即Object// es6提供对class 的__proto__的访问A.__proto__ // A本质是函数，函数也是对象，A是Object的实例，实例对象__proto__是对象类型的原型，这里是 [native code]B.__proto__ // B继承A，B.prototype是A的实例，B是A的实例，所以B.__proto__ === A.prototype 对于class本来就是让我们能够避开传统function的不容易理解的语义，我们实际中尽量不要去使用proto,很多时候把自己给绕晕了。另外，这里补充一句:class内部定义的变量是不能存在变量提升的，也就是说你用了var也是不存在变量提升。因为他是一个语法糖，我们new一个实例时才会走进构造函数栈，执行完后，当前栈被销毁，而里面返回的值赋给了实例的属性，而里面的变量标记会被清除掉，因此不存在变量提升。","categories":[],"tags":[]},{"title":"单链表的创建，遍历，插入，删除","slug":"05","date":"2019-05-11T15:53:59.797Z","updated":"2019-05-11T15:57:00.520Z","comments":true,"path":"2019/05/11/05/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/05/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define LEN sizeof(struct node) struct node //节点类型 &#123; int data; //定义数据域 struct node *next; //定义指针域 &#125;; int n=0; //记录节点的个数 /*头插法创建动态单链表*/ struct node *creatlist() &#123; struct node *head,*p,*q; head=p=(struct node *)malloc(LEN); //创建第一个节点并由head,p指针指向 scanf(&quot;%d&quot;,&amp;p-&gt;data); //为数据域复制 head-&gt;next=NULL; while(p-&gt;data!=0) &#123; n=n+1; //节点数加一 if(n==1) q=p; //使得创建的第二个节点能顺利指向第一个节点 else //链入新节点 &#123; p-&gt;next=q; head=p; &#125; q=p; //使得后来创建的每一个节点都能指向后一个节点 p=(struct node *)malloc(LEN); //创建新节点 scanf(&quot;%d&quot;,&amp;p-&gt;data); //为新创建节点的指针域赋值 &#125; free(p); return(head); &#125; /*单链表的遍历*/ void print(struct node *head) &#123; struct node *p; printf(&quot;\\nthese %d records are:\\n&quot;,n); p=head; if(head!=NULL) do &#123; printf(&quot;%d\\n&quot;,p-&gt;data); p=p-&gt;next; &#125; while(p!=NULL); &#125; /*单链表的插入*/ struct node *insert(struct node *head,int ins_num) &#123; struct node *p,*q1,*q2; q1=head; //使q1指向第一个节点 p=(struct node*)malloc(LEN); p-&gt;data = ins_num; if(head == NULL) //如果原来的链表是空表 &#123; head=p; p-&gt;next=NULL; //使p指向的节点作为空节点 &#125; if(p-&gt;data&lt;head-&gt;data) &#123; head=p; p-&gt;next=q1; //将待插节点放在第一个节点之前 &#125; else &#123; while((p-&gt;data&gt;=q1-&gt;data) &amp;&amp; (q1!=NULL)) &#123; q2=q1; q1=q1-&gt;next; //用循环找到要插入的位置 &#125; q2-&gt;next=p; p-&gt;next=q1; //链入待插节点 &#125; n=n+1; //节点数加1 return(head); //返回头指针 &#125; /*单链表的删除*/ struct node *del(struct node *head,int del_num) &#123; struct node *q1,*q2; q1=head; //让q1指向第一个节点 if(head==NULL) //若是空链表，则提示出错 &#123; printf(&quot;error,list null!&quot;); &#125; else &#123; while((del_num!=q1-&gt;data) &amp;&amp; (q1-&gt;next!=NULL)) //用循环找到要删除的节点位置 &#123; q2=q1; q1=q1-&gt;next; &#125; if(del_num == q1-&gt;data) &#123; if(q1==head) head=q1-&gt;next; //若果q1指向的是首节点，则将head指向第二个节点的位置 else &#123; q2-&gt;next = q1-&gt;next; //将下一节点的地址赋给前一节点的地址 &#125; free(q1); //释放节点空间 n=n-1; &#125; else printf(&quot;%d not been found!\\n&quot;,del_num); &#125; return(head); &#125; void main()&#123; struct node *head; int ins_num,del_num; //定义将要删除的数据 printf(&quot;please input records:\\n&quot;); head = creatlist(); //调用动态单链表建立函数 print(head); //调用print()函数,遍历并输出创建的动态链表 printf(&quot;please input the inserted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;ins_num); while(ins_num != 0) //插入节点 &#123; head = insert(head,ins_num); print(head); printf(&quot;please input the inserted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;ins_num); &#125; printf(&quot;please input the deleted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;del_num); while(del_num!=0) //删除节点 &#123; head = del(head,del_num); print(head); printf(&quot;please input the deleted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;del_num); &#125; &#125;","categories":[],"tags":[]},{"title":"除了感动，无话可说！","slug":"04","date":"2019-05-11T09:40:57.579Z","updated":"2019-05-11T12:12:57.831Z","comments":true,"path":"2019/05/11/04/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/04/","excerpt":"","text":"warriors never quit","categories":[],"tags":[]},{"title":"插入排序","slug":"03","date":"2019-05-11T08:24:48.047Z","updated":"2019-05-11T08:29:28.123Z","comments":true,"path":"2019/05/11/03/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/03/","excerpt":"","text":"C语言实现插入排序（2019.5.11更）12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int i,j,n,k,a[100],t; printf(&quot;请输入你想要排序的数组长度n:&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请随机输入%d个整数：&quot;,n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(j=1;j&lt;n;j++)&#123; k=j-1; while(k&gt;=0&amp;&amp;a[k]&gt;a[j])&#123; t=a[k]; a[k]=a[j]; a[j]=t; k--; j--; &#125; &#125; printf(&quot;经插入排序后的输出结果为：\\n&quot;); for(j=0;j&lt;n;j++) printf(&quot;%3d&quot;,a[j]); printf(&quot;\\n&quot;); printf(&quot;今天是三八妇女节，祝我的妈妈和所有的母亲节日快乐，永远健康!!!&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"选择排序","slug":"02","date":"2019-05-11T08:24:48.047Z","updated":"2019-05-11T08:27:16.151Z","comments":true,"path":"2019/05/11/02/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/02/","excerpt":"","text":"C语言实现选择排序123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int i,j,k,t; int a[20]; printf(&quot;请任意输入20个整数：&quot;); for(i=0;i&lt;20;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;19;i++)&#123; k=i; for(j=i+1;j&lt;=19;j++) if(a[j]&lt;a[k]) k=j; if(k!=i)&#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; &#125; printf(&quot;排序后的结果为：\\n&quot;); for(i=0;i&lt;20;i++) printf(&quot;%3d&quot;,a[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"冒泡排序","slug":"01","date":"2019-05-11T07:16:28.266Z","updated":"2019-05-11T08:22:40.826Z","comments":true,"path":"2019/05/11/01/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/01/","excerpt":"","text":"C语言实现冒泡排序1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int a[20],i,j,t; printf(&quot;请随机输入20个整数：&quot;); for(i=0;i&lt;20;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); getchar(); &#125; for(i=0;i&lt;19;i++) for(j=0;j&lt;19-i;j++)&#123; if(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; printf(&quot;排序结果为：\\n&quot;); for(i=0;i&lt;20;i++) printf(&quot;%d&quot;,a[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-03T10:49:54.680Z","updated":"2019-05-03T10:49:54.680Z","comments":true,"path":"2019/05/03/hello-world/","link":"","permalink":"http://getitkesheng.github.io/2019/05/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}