{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"kesheng","url":"http://getitkesheng.github.io","root":"/"},"pages":[],"posts":[{"title":"关于JS对象原型prototype与继承，ES6的class和extends","slug":"06","date":"2019-05-12T03:07:07.520Z","updated":"2019-05-12T03:17:44.427Z","comments":true,"path":"2019/05/12/06/","link":"","permalink":"http://getitkesheng.github.io/2019/05/12/06/","excerpt":"","text":"传统方式：通过function关键字来定义一个对象类型1234567891011function People(name) &#123; this.name = name&#125;People.prototype.toSay= function () &#123; alert(&quot;我的名字是：&quot; + this.name)&#125;People.prototype.toEat= function () &#123; alert(&quot;我吃饭&quot;)&#125;var p = new People(&quot;小明&quot;)p.toSay(); // 我的名字是小明 上面的代码里，我们定义People这种类型，它的属性特征有name、toSay、toEat 。然后我们以People为模板new出来一个p的实例对象。刚接触js时，可能会疑惑，function声明的不是函数么，怎么又变成定义对象类型？prototype是什么？其实在js中，函数本身也是一个对象。这种对象有点特殊，它的作用是定义了对象类型，可以说是数据结构模板。 而prototype是它的一个属性，称为对象原型，其本质也是一个对象，包含constructor和其他属性成员。constructor默认指向自身构造函数。所以声明People的时候，程序自动People对象添加了prototype属性，并且让prototype.constructor指向了People，即函数本身。所以上面的例子等同于下面的写法：12345678910111213function People(name) &#123; this.name = name&#125;var proto = &#123; constructor : People, toSay: function (name) &#123; alert(&quot;我的名字是：&quot; + name) &#125;, toEat: function() &#123; alert(&quot;我吃饭&quot;) &#125;&#125;People.prototype = proto // 指定People的Prototype属性 prototype的作用：当我们new一个实例对象p时，程序根据对象类型People的原型prototype，将原型所定义的属性（constructor除外）复制给新的实例对象p，并执行了一次prototype.constructor 所指向的构造函数，对实例对象p进行初始化。实例对象p有两种属性：实例属性、原型属性实例属性： 构造方法里定义的原型属性： 在原型prototype里定义hasOwnProperty方法可以帮我们区分p.hasOwnProperty(“name”); // truep.hasOwnProperty(“toSay”); // false,因为这个属性是原型上定义的 问题1：为什么我们不直接都在构造函数里面定义呢？123456789function People(name) &#123; this.name = name this.toSay = function() &#123; alert(&quot;我的名字是：&quot; + this.name) &#125; this.toEat = function() &#123; alert(&quot;我吃饭&quot;) &#125;&#125; 答： 这个主要考虑内存管理，因为函数是内存中的一个对象，也就是说，toSay或toEat都是对象占有一定内存。写在构造函数里面，每new一个实例对象，都会执行一次构造函数，都会重新创建一个函数对象，赋给新的实例对象的属性上。结果就是每一个实例对象的toSay或toEat属性都对应各自的函数对象，而这些函数功能都是一样的，我们创建了一大堆重复的函数对象。使用prototype不会，因为大家共享一个prototype对象。问题2： 为什么name不是直接定义在原型prototype上呢？答：每个人名字不同，如果定义在prototype上，大家名字就一样了，其中一个改变了name值，都会影响到其他实例对象。注意：实例对象是没有prototype属性，所以你不可以用实例对象为模板new一个新的实例对象来，只能用函数对象为模板来创建。var p1 = new People(‘’小明”)； // 正确，函数对象的prototype的constructor指定构造方法var p2 = new p1(“小王”) ； // error ,实例对象没有prototype，找不到构造方法 各大浏览器厂商给实例对象实现了一个 proto 属性，指向对象原型，我们称为实例对象的隐式原型，即：var p1 = new People(“小明”)p1.proto === People.prototype // true 但我们要避免使用这个属性， 这个属性作用我猜测是浏览器提供给我们方便调试的时候用的。 问题1：People.prototype是一个对象，这个对象是什么？答：Object， js所有对象默认继承js内置对象Object。问题2： js中，怎么实现对象的继承？答：js的继承是通过对象原型prototype来实现的。1234567891011121314151617// 父类型function Animal(name) &#123; this.name= name this.hasFoot = true this.color = [&quot;orange&quot;, &apos;&apos;black&quot;]&#125;Animal.prototype = &#123; constructor: Animal, voice: function(word) &#123; console.info(word) &#125; &#125;// 子类型 Catfunction Cat() &#123;&#125;Cat.prototype = new Animal(&quot;cat&quot;); // Cat.prototype.constructor是AnimalCat.prototype.constructor = Cat; // 我们将构造函数指定回来，因为我们可以在构造扩展其它属性 上面的代码，我们就实现了Cat的对象类型是继承了Animal对象类型，所以我们可以看到：1234var cat1 = new Cat()cat1.hasFoot // truecat1.color // [&quot;orange&quot;,&quot;black&quot;]cat1.toString // function toString() &#123; [native code] &#125; hasFoot、与footNum都是从父类型annimal继承过来的，而toString为什么有呢，其实是这样，Cat继承了Animal，而Animal默认继承了Object，所以当我们找cat1的toString属性是，发现自身实例属性没有，发现原型上也没有定义，那程序就会寻所继承的父对象的实例属性，父对象的原型属性，这样一步步找下去，这就是JS的原型链。所以就是：12cat1.__proto__ === Cat.prototype // truecat1.__proto__.__proto__ === Animal.prototype // true ,因为Cat.prototype是一个Animal的实例对象 上面的程序设计存在一个问题，有的猫只有一种颜色，有猫身上的颜色有三种，橘、白、黑。显然从Animal继承过来的颜色只有不能满足这种情况1234var cat2 =new Cat()cat2.color.push(&quot;white&quot;);cat1.color // [&quot;orange&quot;, &quot;black&quot;, &quot;white&quot;]//原因是因为，color是来自Cat.prototype，cat1和cat2共享一个prototype，你改变了cat2，cat1的color原型属性就会受到影响 面对这种情况，我们的Cat对象类型应该这么写：12345678function Cat() &#123; Animal.call(this) // 这样就可以将原型的实例属性变成自身的实例属性&#125;Cat.prototype = new Animal()Cat.prototype.constructor = Catvar cat1 = new Cat()var cat2 = new Cat()cat1.color === cat2.color // false 虽然的方式解决了问题，但是还是有个缺点，调用了两次Animal构造函数。第一次是指定Cat.prototype，第二次是Cat自身构造函数中主动调用。我们更想要的是，指定了prototype，new实例时，构造函数就不要再调用Animal()了。此时我们需要一个工具来完成1234567891011// 工具extendfunction extend(super, suber) &#123; var proto = Object.create(super.prototype) proto.constructor = suber suber.prototype = proto&#125;function Cat() &#123; Animal.call(this); &#125;extend(Animal, Cat) 上面的这种方式，将指定Cat.prototype从通过new Animal()换成直接Object.creat(Animal.prototype),这样就避免了Animal() 构造函数的执行。实际上，这方式是最高效的方式。对比其他面向对象开发语言(如： java)，js通过function定义对象类型，容易让人不理解。ES6新规范推出class和extends关键字来实现面向对象编程。ES6方式：用class关键字定义对象类型，用extends关键字实现继承12345678910111213141516171819202122232425262728const private2 = Symbol(&apos;I am symbol value&apos;)class A &#123; a1 = &apos;1&apos; // ES7 实例属性，需要new实例来访问, ES6规定class没有静态属性，只有静态方法所以只能在constructor中定义属性 static a2 = &apos;2&apos; // ES7的静态属性，直接 A.a2 访问，不需要new实例 getA1() &#123; return this.a1 // this指向new实例 &#125; static getA2() &#123; return ‘2’ // 静态方法 &#125; constructor(name) &#123; //一定要有构造方法，如果没有默认生成空构造方法 this.a3 = &apos;3&apos; // 这里定义实例属性 this.name = name &#125; // 私有方法写法 publicMethod() &#123; private1() // 私有方法1，可以写在class体外 private2() // 利用Symbol值来定义 &#125; [private2]() &#123; // 这里是私有方法 &#125;&#125;const private1 = function() &#123; // 这里也是私有方法，但别export出去&#125;// 最后export classexport default A class关键字会让我们更清晰设计一个对象类型，实际上,这只是语法糖： A 的实质还是一个function对属性的定义是实例属性，而对方法的定义是定义在原型上 // 通过extends继承12345678class B extends A&#123; constructor() &#123; // 一定要在构造函数的第一句调用super super() // 这是调用父类的构造方法 this.b1 = &apos;11&apos; this.b2 = super.a1 // super直接调用时指向父类构造方法，范围属性时，指向父类实例，或调用父类静态方法 &#125;&#125; 我们可以知道，实际上A、B都是两个对象类型，B继承A。ES6的class作为语法糖也提供了prototype和proto两个属性；1234567891011let instanceA = new A()let instanceB = new B()A.prototype // ObjectinstanceA.__proto__ //即A.prototype 还是ObjectB.prototype // A的实例对象，并且constructor指定为ClassBinstanceB.__proto__ //B.prototypeinstanceB.__proto__.__proto__ // 即A.prototype ,即Object// es6提供对class 的__proto__的访问A.__proto__ // A本质是函数，函数也是对象，A是Object的实例，实例对象__proto__是对象类型的原型，这里是 [native code]B.__proto__ // B继承A，B.prototype是A的实例，B是A的实例，所以B.__proto__ === A.prototype 对于class本来就是让我们能够避开传统function的不容易理解的语义，我们实际中尽量不要去使用proto,很多时候把自己给绕晕了。另外，这里补充一句:class内部定义的变量是不能存在变量提升的，也就是说你用了var也是不存在变量提升。因为他是一个语法糖，我们new一个实例时才会走进构造函数栈，执行完后，当前栈被销毁，而里面返回的值赋给了实例的属性，而里面的变量标记会被清除掉，因此不存在变量提升。","categories":[],"tags":[]},{"title":"单链表的创建，遍历，插入，删除","slug":"05","date":"2019-05-11T15:53:59.797Z","updated":"2019-05-11T15:57:00.520Z","comments":true,"path":"2019/05/11/05/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/05/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define LEN sizeof(struct node) struct node //节点类型 &#123; int data; //定义数据域 struct node *next; //定义指针域 &#125;; int n=0; //记录节点的个数 /*头插法创建动态单链表*/ struct node *creatlist() &#123; struct node *head,*p,*q; head=p=(struct node *)malloc(LEN); //创建第一个节点并由head,p指针指向 scanf(&quot;%d&quot;,&amp;p-&gt;data); //为数据域复制 head-&gt;next=NULL; while(p-&gt;data!=0) &#123; n=n+1; //节点数加一 if(n==1) q=p; //使得创建的第二个节点能顺利指向第一个节点 else //链入新节点 &#123; p-&gt;next=q; head=p; &#125; q=p; //使得后来创建的每一个节点都能指向后一个节点 p=(struct node *)malloc(LEN); //创建新节点 scanf(&quot;%d&quot;,&amp;p-&gt;data); //为新创建节点的指针域赋值 &#125; free(p); return(head); &#125; /*单链表的遍历*/ void print(struct node *head) &#123; struct node *p; printf(&quot;\\nthese %d records are:\\n&quot;,n); p=head; if(head!=NULL) do &#123; printf(&quot;%d\\n&quot;,p-&gt;data); p=p-&gt;next; &#125; while(p!=NULL); &#125; /*单链表的插入*/ struct node *insert(struct node *head,int ins_num) &#123; struct node *p,*q1,*q2; q1=head; //使q1指向第一个节点 p=(struct node*)malloc(LEN); p-&gt;data = ins_num; if(head == NULL) //如果原来的链表是空表 &#123; head=p; p-&gt;next=NULL; //使p指向的节点作为空节点 &#125; if(p-&gt;data&lt;head-&gt;data) &#123; head=p; p-&gt;next=q1; //将待插节点放在第一个节点之前 &#125; else &#123; while((p-&gt;data&gt;=q1-&gt;data) &amp;&amp; (q1!=NULL)) &#123; q2=q1; q1=q1-&gt;next; //用循环找到要插入的位置 &#125; q2-&gt;next=p; p-&gt;next=q1; //链入待插节点 &#125; n=n+1; //节点数加1 return(head); //返回头指针 &#125; /*单链表的删除*/ struct node *del(struct node *head,int del_num) &#123; struct node *q1,*q2; q1=head; //让q1指向第一个节点 if(head==NULL) //若是空链表，则提示出错 &#123; printf(&quot;error,list null!&quot;); &#125; else &#123; while((del_num!=q1-&gt;data) &amp;&amp; (q1-&gt;next!=NULL)) //用循环找到要删除的节点位置 &#123; q2=q1; q1=q1-&gt;next; &#125; if(del_num == q1-&gt;data) &#123; if(q1==head) head=q1-&gt;next; //若果q1指向的是首节点，则将head指向第二个节点的位置 else &#123; q2-&gt;next = q1-&gt;next; //将下一节点的地址赋给前一节点的地址 &#125; free(q1); //释放节点空间 n=n-1; &#125; else printf(&quot;%d not been found!\\n&quot;,del_num); &#125; return(head); &#125; void main()&#123; struct node *head; int ins_num,del_num; //定义将要删除的数据 printf(&quot;please input records:\\n&quot;); head = creatlist(); //调用动态单链表建立函数 print(head); //调用print()函数,遍历并输出创建的动态链表 printf(&quot;please input the inserted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;ins_num); while(ins_num != 0) //插入节点 &#123; head = insert(head,ins_num); print(head); printf(&quot;please input the inserted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;ins_num); &#125; printf(&quot;please input the deleted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;del_num); while(del_num!=0) //删除节点 &#123; head = del(head,del_num); print(head); printf(&quot;please input the deleted record:\\n&quot;); scanf(&quot;%d&quot;,&amp;del_num); &#125; &#125;","categories":[],"tags":[]},{"title":"除了感动，无话可说！","slug":"04","date":"2019-05-11T09:40:57.579Z","updated":"2019-05-11T12:12:57.831Z","comments":true,"path":"2019/05/11/04/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/04/","excerpt":"","text":"warriors never quit","categories":[],"tags":[]},{"title":"插入排序","slug":"03","date":"2019-05-11T08:24:48.047Z","updated":"2019-05-11T08:29:28.123Z","comments":true,"path":"2019/05/11/03/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/03/","excerpt":"","text":"C语言实现插入排序（2019.5.11更）12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int i,j,n,k,a[100],t; printf(&quot;请输入你想要排序的数组长度n:&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请随机输入%d个整数：&quot;,n); for(i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(j=1;j&lt;n;j++)&#123; k=j-1; while(k&gt;=0&amp;&amp;a[k]&gt;a[j])&#123; t=a[k]; a[k]=a[j]; a[j]=t; k--; j--; &#125; &#125; printf(&quot;经插入排序后的输出结果为：\\n&quot;); for(j=0;j&lt;n;j++) printf(&quot;%3d&quot;,a[j]); printf(&quot;\\n&quot;); printf(&quot;今天是三八妇女节，祝我的妈妈和所有的母亲节日快乐，永远健康!!!&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"选择排序","slug":"02","date":"2019-05-11T08:24:48.047Z","updated":"2019-05-11T08:27:16.151Z","comments":true,"path":"2019/05/11/02/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/02/","excerpt":"","text":"C语言实现选择排序123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main()&#123; int i,j,k,t; int a[20]; printf(&quot;请任意输入20个整数：&quot;); for(i=0;i&lt;20;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=0;i&lt;19;i++)&#123; k=i; for(j=i+1;j&lt;=19;j++) if(a[j]&lt;a[k]) k=j; if(k!=i)&#123; t=a[k]; a[k]=a[i]; a[i]=t; &#125; &#125; printf(&quot;排序后的结果为：\\n&quot;); for(i=0;i&lt;20;i++) printf(&quot;%3d&quot;,a[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"冒泡排序","slug":"01","date":"2019-05-11T07:16:28.266Z","updated":"2019-05-11T08:22:40.826Z","comments":true,"path":"2019/05/11/01/","link":"","permalink":"http://getitkesheng.github.io/2019/05/11/01/","excerpt":"","text":"C语言实现冒泡排序1234567891011121314151617181920212223#include&lt;stdio.h&gt;int main()&#123; int a[20],i,j,t; printf(&quot;请随机输入20个整数：&quot;); for(i=0;i&lt;20;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); getchar(); &#125; for(i=0;i&lt;19;i++) for(j=0;j&lt;19-i;j++)&#123; if(a[j]&gt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; printf(&quot;排序结果为：\\n&quot;); for(i=0;i&lt;20;i++) printf(&quot;%d&quot;,a[i]); return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-05-03T10:49:54.680Z","updated":"2019-05-03T10:49:54.680Z","comments":true,"path":"2019/05/03/hello-world/","link":"","permalink":"http://getitkesheng.github.io/2019/05/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}